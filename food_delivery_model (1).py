# -*- coding: utf-8 -*-
"""Food Delivery Model.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1z3fe7zaM8zO6VU3uDYw7Tw105AFdXgJ9
"""

!pip install google-ml-edu==0.1.3 \
  keras~=3.8.0 \
  matplotlib~=3.10.0 \
  numpy~=2.0.0 \
  pandas~=2.2.0 \
  tensorflow~=2.19.0

#@title Code - Load dependencies

# data
import numpy as np
import pandas as pd

# machine learning
import keras
import ml_edu.experiment
import ml_edu.results

# data visualization
import plotly.express as px

food_delivery_dataset = pd.read_csv("delivery_data.csv")

#@title Code - Read dataset

# Updates dataframe to use specific columns.
training_df = food_delivery_dataset.loc[:, ('ORDER_DISTANCE', 'PREP_TIME', 'TRAFFIC_INDEX', 'DELIVERY_TIME','DISTANCE x TRAFFIC','PREP_TIME x TRAFFIC INDEX', 'DISTANCE_SQ','TRAFFIC_SQ')]

print('Read dataset completed successfully.')
print('Total number of rows: {0}\n\n'.format(len(training_df.index)))

#@title Code - View dataset statistics

print('Total number of rows: {0}\n\n'.format(len(training_df.index)))
training_df.describe(include='all')

#@title Code - View correlation matrix
training_df.corr(numeric_only = True)

#@title Code - View pairplot
px.scatter_matrix(training_df, dimensions=["DELIVERY_TIME", "ORDER_DISTANCE", "PREP_TIME", "TRAFFIC_INDEX","DISTANCE x TRAFFIC",
    "PREP_TIME x TRAFFIC INDEX","DISTANCE_SQ","TRAFFIC_SQ"])

#@title Code - Scale Features using Standardization

features = [
    "ORDER_DISTANCE",
    "PREP_TIME",
    "TRAFFIC_INDEX",
    "DISTANCE x TRAFFIC",
    "PREP_TIME x TRAFFIC INDEX",
    "DISTANCE_SQ",
    "TRAFFIC_SQ"
]

label = "DELIVERY_TIME"

from sklearn.preprocessing import StandardScaler

scaler = StandardScaler()
training_df[features] = scaler.fit_transform(training_df[features])

#@title Code - Define ML functions

def create_model(
    settings: ml_edu.experiment.ExperimentSettings,
    metrics: list[keras.metrics.Metric],
) -> keras.Model:
  """Create and compile a simple linear regression model."""
  # Describe the topography of the model.
  # The topography of a simple linear regression model
  # is a single node in a single layer.
  inputs = {name: keras.Input(shape=(1,), name=name) for name in settings.input_features}
  concatenated_inputs = keras.layers.Concatenate()(list(inputs.values()))
  outputs = keras.layers.Dense(units=1)(concatenated_inputs)
  model = keras.Model(inputs=inputs, outputs=outputs)

  # Compile the model topography into code that Keras can efficiently
  # execute. Configure training to minimize the model's mean squared error.
  model.compile(optimizer=keras.optimizers.RMSprop(learning_rate=settings.learning_rate),
                loss="mean_squared_error",
                metrics=metrics)

  return model


def train_model(
    experiment_name: str,
    model: keras.Model,
    dataset: pd.DataFrame,
    label_name: str,
    settings: ml_edu.experiment.ExperimentSettings,
) -> ml_edu.experiment.Experiment:
  """Train the model by feeding it data."""

  # Feed the model the feature and the label.
  # The model will train for the specified number of epochs.
  features = {name: dataset[name].values for name in settings.input_features}
  label = dataset[label_name].values
  history = model.fit(x=features,
                      y=label,
                      batch_size=settings.batch_size,
                      epochs=settings.number_epochs)

  return ml_edu.experiment.Experiment(
      name=experiment_name,
      settings=settings,
      model=model,
      epochs=history.epoch,
      metrics_history=pd.DataFrame(history.history),
  )

print("SUCCESS: defining linear regression functions complete.")

#@title Code - Experiment 1

# The following variables are the hyperparameters.
settings_1 = ml_edu.experiment.ExperimentSettings(
    learning_rate = 0.6,
    number_epochs = 25,
    batch_size = 2,
    input_features = ['PREP_TIME']
)

metrics = [keras.metrics.RootMeanSquaredError(name='rmse')]

model_1 = create_model(settings_1, metrics)

experiment_1 = train_model('one_feature', model_1, training_df, 'DELIVERY_TIME', settings_1)

ml_edu.results.plot_experiment_metrics(experiment_1, ['rmse'])
ml_edu.results.plot_model_predictions(experiment_1, training_df, 'DELIVERY_TIME', sample_size=10)

#@title Code - Experiment 2

# The following variables are the hyperparameters.
settings_2 = ml_edu.experiment.ExperimentSettings(
    learning_rate = 0.5,
    number_epochs = 25,
    batch_size = 2,
    input_features = ['DISTANCE x TRAFFIC']
)

metrics = [keras.metrics.RootMeanSquaredError(name='rmse')]

model_2 = create_model(settings_2, metrics)

experiment_2 = train_model('one_feature', model_2, training_df, 'DELIVERY_TIME', settings_2)

ml_edu.results.plot_experiment_metrics(experiment_2, ['rmse'])
ml_edu.results.plot_model_predictions(experiment_2, training_df, 'DELIVERY_TIME', sample_size=10)

#@title Code - Experiment 3

# The following variables are the hyperparameters.
settings_3 = ml_edu.experiment.ExperimentSettings(
    learning_rate = 0.5,
    number_epochs = 25,
    batch_size = 2,
    input_features = ['PREP_TIME x TRAFFIC INDEX']
)

metrics = [keras.metrics.RootMeanSquaredError(name='rmse')]

# Fix: Create model_3 with settings_3 instead of settings_1
model_3 = create_model(settings_3, metrics)

experiment_3 = train_model('one_feature', model_3, training_df, 'DELIVERY_TIME', settings_3)

ml_edu.results.plot_experiment_metrics(experiment_3, ['rmse'])
ml_edu.results.plot_model_predictions(experiment_3, training_df, 'DELIVERY_TIME', sample_size=10)

#@title Code - Experiment 4

# The following variables are the hyperparameters.
settings_4 = ml_edu.experiment.ExperimentSettings(
    learning_rate = 0.52,
    number_epochs = 30,
    batch_size = 2,
    input_features = ['DISTANCE_SQ']
)

metrics = [keras.metrics.RootMeanSquaredError(name='rmse')]

model_4 = create_model(settings_4, metrics)

experiment_4 = train_model('one_feature', model_4, training_df, 'DELIVERY_TIME', settings_4)

ml_edu.results.plot_experiment_metrics(experiment_4, ['rmse'])
ml_edu.results.plot_model_predictions(experiment_4, training_df, 'DELIVERY_TIME', sample_size=10)

#@title Code - Experiment 5

# The following variables are the hyperparameters.
settings_5 = ml_edu.experiment.ExperimentSettings(
    learning_rate = 0.5,
    number_epochs = 30,
    batch_size = 2,
    input_features = ['ORDER_DISTANCE']
)

metrics = [keras.metrics.RootMeanSquaredError(name='rmse')]

model_5 = create_model(settings_5, metrics)

experiment_5 = train_model('one_feature', model_5, training_df, 'DELIVERY_TIME', settings_5)

ml_edu.results.plot_experiment_metrics(experiment_5, ['rmse'])
ml_edu.results.plot_model_predictions(experiment_5, training_df, 'DELIVERY_TIME', sample_size=10)

#@title Code - Experiment 6

# The following variables are the hyperparameters.
settings_6 = ml_edu.experiment.ExperimentSettings(
    learning_rate = 0.4,
    number_epochs = 35,
    batch_size = 2,
    input_features = ['ORDER_DISTANCE', 'TRAFFIC_INDEX']
)


metrics = [keras.metrics.RootMeanSquaredError(name='rmse')]

model_6 = create_model(settings_6, metrics)

experiment_6 = train_model('two_features', model_6, training_df, 'DELIVERY_TIME', settings_6)

ml_edu.results.plot_experiment_metrics(experiment_6, ['rmse'])
ml_edu.results.plot_model_predictions(experiment_6, training_df, 'DELIVERY_TIME',sample_size = 10)

#@title Code - Experiment 7

# The following variables are the hyperparameters.
settings_7 = ml_edu.experiment.ExperimentSettings(
    learning_rate = 0.4,
    number_epochs = 35,
    batch_size = 2,
    input_features = ['PREP_TIME', 'TRAFFIC_INDEX']
)


metrics = [keras.metrics.RootMeanSquaredError(name='rmse')]

model_7 = create_model(settings_7, metrics)

experiment_7 = train_model('two_features', model_7, training_df, 'DELIVERY_TIME', settings_7)

ml_edu.results.plot_experiment_metrics(experiment_7, ['rmse'])
ml_edu.results.plot_model_predictions(experiment_7, training_df, 'DELIVERY_TIME',sample_size = 10)

#@title Code - Experiment 8

# The following variables are the hyperparameters.
settings_8 = ml_edu.experiment.ExperimentSettings(
    learning_rate = 0.4,
    number_epochs = 35,
    batch_size = 2,
    input_features = ['DISTANCE x TRAFFIC', 'PREP_TIME']
)


metrics = [keras.metrics.RootMeanSquaredError(name='rmse')]

model_8 = create_model(settings_8, metrics)

experiment_8 = train_model('two_features', model_8, training_df, 'DELIVERY_TIME', settings_8)

ml_edu.results.plot_experiment_metrics(experiment_8, ['rmse'])
ml_edu.results.plot_model_predictions(experiment_8, training_df, 'DELIVERY_TIME',sample_size = 10)

#@title Code - Experiment 9

# The following variables are the hyperparameters.
settings_9 = ml_edu.experiment.ExperimentSettings(
    learning_rate = 0.35,
    number_epochs = 35,
    batch_size = 2,
    input_features = ['ORDER_DISTANCE', 'PREP_TIME x TRAFFIC INDEX', 'DISTANCE_SQ', 'PREP_TIME','DISTANCE x TRAFFIC']
)


metrics = [keras.metrics.RootMeanSquaredError(name='rmse')]

model_9 = create_model(settings_9, metrics)

experiment_9 = train_model('five_features', model_9, training_df, 'DELIVERY_TIME', settings_9)

ml_edu.results.plot_experiment_metrics(experiment_9, ['rmse'])
ml_edu.results.plot_model_predictions(experiment_9, training_df, 'DELIVERY_TIME',sample_size = 10)

ml_edu.results.compare_experiment([experiment_2, experiment_3, experiment_8, experiment_9], ['rmse'], training_df, training_df['DELIVERY_TIME'].values)

#@title Code - Define functions to make predictions

# ---------- Utility Functions ----------

def format_time(minutes):
    """Convert minutes (float) to HH:MM:SS"""
    seconds = int(round(minutes * 60))
    h = seconds // 3600
    m = (seconds % 3600) // 60
    s = seconds % 60
    return f"{h:02d}:{m:02d}:{s:02d}"


def build_batch(df, batch_size):
    """Randomly sample a batch and reset index"""
    batch = df.sample(n=batch_size).copy()
    batch.reset_index(drop=True, inplace=True)
    return batch


# ---------- Prediction Function ----------

def predict_delivery_time(model, df, features, label, batch_size=2):
    batch = build_batch(df, batch_size)

    # Prepare inputs in the format the model expects (dictionary of reshaped arrays)
    model_inputs = {name: batch[name].values.reshape(-1, 1) for name in features}

    # Predict
    predictions = model.predict_on_batch(model_inputs).flatten()

    # Prepare output container
    data = {
        "PREDICTED_DELIVERY_TIME": [],
        "OBSERVED_DELIVERY_TIME": [],
        "L1_LOSS (minutes)": []
    }

    # Dynamically add feature columns
    for feature in features:
        data[feature] = []

    # Populate output
    for i in range(batch_size):
        predicted = float(predictions[i])
        observed = float(batch.at[i, label])
        l1_loss = abs(observed - predicted)

        data["PREDICTED_DELIVERY_TIME"].append(format_time(predicted))
        data["OBSERVED_DELIVERY_TIME"].append(format_time(observed))
        data["L1_LOSS (minutes)"].append(round(l1_loss, 3))

        for feature in features:
            data[feature].append(batch.at[i, feature])

    return pd.DataFrame(data)


# ---------- Display Function ----------

def show_predictions(output_df):
    header = "-" * 80
    banner = f"{header}\n|{'PREDICTIONS':^78}|\n{header}"
    print(banner)
    print(output_df.to_string(index=False))

#@title Code - Make predictions

output = predict_delivery_time(experiment_9.model, training_df, experiment_9.settings.input_features, 'DELIVERY_TIME')
show_predictions(output)